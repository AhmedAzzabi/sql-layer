/**
 * END USER LICENSE AGREEMENT (“EULA”)
 *
 * READ THIS AGREEMENT CAREFULLY (date: 9/13/2011):
 * http://www.akiban.com/licensing/20110913
 *
 * BY INSTALLING OR USING ALL OR ANY PORTION OF THE SOFTWARE, YOU ARE ACCEPTING
 * ALL OF THE TERMS AND CONDITIONS OF THIS AGREEMENT. YOU AGREE THAT THIS
 * AGREEMENT IS ENFORCEABLE LIKE ANY WRITTEN AGREEMENT SIGNED BY YOU.
 *
 * IF YOU HAVE PAID A LICENSE FEE FOR USE OF THE SOFTWARE AND DO NOT AGREE TO
 * THESE TERMS, YOU MAY RETURN THE SOFTWARE FOR A FULL REFUND PROVIDED YOU (A) DO
 * NOT USE THE SOFTWARE AND (B) RETURN THE SOFTWARE WITHIN THIRTY (30) DAYS OF
 * YOUR INITIAL PURCHASE.
 *
 * IF YOU WISH TO USE THE SOFTWARE AS AN EMPLOYEE, CONTRACTOR, OR AGENT OF A
 * CORPORATION, PARTNERSHIP OR SIMILAR ENTITY, THEN YOU MUST BE AUTHORIZED TO SIGN
 * FOR AND BIND THE ENTITY IN ORDER TO ACCEPT THE TERMS OF THIS AGREEMENT. THE
 * LICENSES GRANTED UNDER THIS AGREEMENT ARE EXPRESSLY CONDITIONED UPON ACCEPTANCE
 * BY SUCH AUTHORIZED PERSONNEL.
 *
 * IF YOU HAVE ENTERED INTO A SEPARATE WRITTEN LICENSE AGREEMENT WITH AKIBAN FOR
 * USE OF THE SOFTWARE, THE TERMS AND CONDITIONS OF SUCH OTHER AGREEMENT SHALL
 * PREVAIL OVER ANY CONFLICTING TERMS OR CONDITIONS IN THIS AGREEMENT.
 */

package com.akiban.sql.test;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Date;

/*
 * translates the MySQL test files into our yaml format
 * */
public class MySQLTestTranslator {

    StringBuilder data = new StringBuilder();
    StringBuilder tempData = new StringBuilder();
    StringBuilder blockData = new StringBuilder();
    String[] realdata = new String[1];
    int orderBy = 0;
    String[][] alldata;
    int smallCounter = 0;
    final String target_path = System.getProperty("user.dir")
            + "/src/test/resources/com/akiban/sql/pg/yaml/mysql-test/";
    private static final String skip_key = "# AUTOGEN: SKIP";
    public static final String single_quote = "'";
    
    // It is also possible to filter the list of returned files.
    // This example does not return any files that start with `.'.
    final FilenameFilter filter = new FilenameFilter() {
        public boolean accept(final File dir, final String name) {
            boolean accept;
            
            accept = name.startsWith("in")
                    && (name.endsWith(".result") || (name.startsWith("data") && name
                            .endsWith(".inc")));
            return accept;
        }
    };
    
    /**
     * @param args
     */
    public static void main(String[] args) {
        final MySQLTestTranslator b = new MySQLTestTranslator();
        
        b.run("/Users/CErnenwein/Downloads/mysql-5.5.19-osx10.6-x86_64/mysql-test/suite/engines/funcs/r");
        System.out.println("Done!!!!");
    }

    public void run(final String directory) {
        final File dir = new File(directory);

        final String[] children = dir.list(filter);
        if (children == null) {
            System.err.println("Either dir does not exist or is not a directory");
        } else {
            for (int i = 0; i < children.length; i++) {
                // Get filename of file or directory
                processFile(directory + "/" + children[i]);
            }
        }
    }

    public void processFile(final String filename) {
        //Read filename (test.result)
        //process each line into data sb
        //write out data
        final int dashPos = filename.lastIndexOf("/") + 1;
        String strFilename = filename.substring(dashPos);
        final int dotPos = strFilename.lastIndexOf(".");
        strFilename = strFilename.replaceAll("_", "-");
        strFilename = "test-" + strFilename.substring(0, dotPos) + ".yaml";
        System.out.println("Processing: " + filename);
        if (checkTargetFile(target_path + strFilename)) {

            return;
        }

        data.append("# generated by com.akiban.sql.test.MySQLTestTranslator on "
                + new Date() + System.getProperty("line.separator"));
        if (!strFilename.startsWith("test-se")) {
            data.append("---" + System.getProperty("line.separator"));
            data.append("- Properties: all"
                    + System.getProperty("line.separator"));
            data.append("- suppressed: true"
                    + System.getProperty("line.separator"));
        }
        //data.append("---" + System.getProperty("line.separator"));
        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader(filename));
            String strLine;
            //Read File Line By Line
            while ((strLine = br.readLine()) != null) {
                strLine = strLine.replaceAll("\\u0000", "");
                //System.out.println(strLine);

                if (strLine.toUpperCase().startsWith("CREATE TABLE")) {
                    translateCreateTable(strLine);
                } else if (strLine.toUpperCase().startsWith("INSERT")) {
                    translateStatement(strLine);
                } else if (strLine.toUpperCase().startsWith("DELETE")) {
                    translateStatement(strLine);
                } else if (strLine.toUpperCase().startsWith("UPDATE")) {
                    translateStatement(strLine);
                } else if (strLine.toUpperCase().startsWith("SELECT")) {
                    translateSelect(strLine);
                } else if (strLine.toUpperCase().startsWith("TRUNCATE TABLE")) {
                    translateTruncateTable(strLine);
                } else if (strLine.toUpperCase().startsWith("--SOURCE")) {
                    translateInclude(strLine);
                } else if (strLine.toUpperCase().startsWith("DROP TABLE")) {
                    translateDropTable(strLine);
                } else if (strLine.toUpperCase().startsWith("ERROR")) {
                    translateError(strLine);
                } else if (strLine.toUpperCase().startsWith("--")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("End of")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith(";")) {
                    // skip line
                } else if (strLine.toUpperCase().startsWith("STOP")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("START")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("PARTITION")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("SHOW")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("RESET")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("SET")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("WARNING")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("NOTE")) {
                    translateWarning(br.readLine());
                } else if (strLine.toUpperCase().startsWith("LOAD")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("USE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("CREATE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("DROP DATABASE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("ANALYZE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("DROP INDEX")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("DROP VIEW")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("ALTER")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("EXECUTE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("PREPARE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("REPLACE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("DEALLOCATE")) {
                    translateComment(strLine);
                } else if (strLine.length() > 0) {
                    translateData(strLine);
                }
                
                
            }
            //Close the input stream
            
        } catch (final Exception e) {//Catch exception if any
            System.err.println("Error: " + e.getMessage());
        } finally {
            try {
                br.close();
            } catch (IOException e) {
                System.err.println("Error: " + e.getMessage());
            }
        }

        data.append("..." + System.getProperty("line.separator"));

        try {
            // will drop the files in the same branch as where this code is running
            // sql gets dropped in the root directory of branch

            System.out.println("Writing out " + target_path + strFilename);
            save(target_path + strFilename, data);
        } catch (final IOException e) {
            System.err.println("Error: " + e.getMessage());
        }
        data = new StringBuilder();
    }

    private void translateWarning(String strLine) {
        // source: # Note       1265    Data truncated for column 'c1' at row 1
        // output: #- warnings: [[1, 'WARN:   Data truncated for column ''C1'' at row 1']]
        strLine = strLine.replaceAll(single_quote, single_quote+single_quote);
        strLine = strLine.substring(10);
        blockData.append("#- warnings: [1,'" + strLine + "']"
                + System.getProperty("line.separator"));
    }

    /* return true to skip processing file because target file is working
     don't mess with it
     */
    private boolean checkTargetFile(String strFilename) {
        boolean retVal = false;
        File f = new File(strFilename);
        f.mkdirs();
        if (f.exists()) {

            BufferedReader br = null;
            try {
                br = new BufferedReader(new FileReader(strFilename));
                String strLine;
                //Read File Line By Line

                while (!retVal && (strLine = br.readLine()) != null) {
                    if (strLine.contains(skip_key)) {
                        retVal = true;
                    }
                }
            } catch (IOException e) {
                System.err.println("Error: " + e.getMessage());
            } finally {
                //Close the input stream
                try {
                    br.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
        return retVal;
    }

    private void translateError(String strLine) {
        strLine = strLine.replaceAll(single_quote, single_quote+single_quote);
        strLine = strLine.split(":")[0];
        strLine = strLine.replaceAll(":"," ");
        strLine = strLine.replaceAll("23000","23501");
        strLine = strLine.replaceAll("ERROR ","");
        blockData.append("- error: ['" + strLine + "']"
                + System.getProperty("line.separator"));
    }

    private void translateTruncateTable(String strLine) {
        finishData();
        strLine = strLine.replaceAll(";", "");
        strLine = strLine.replaceAll(" t1 "," T1 ");
        strLine = strLine.replaceAll(" t2 "," T2 ");
        strLine = strLine.replaceAll(" t3 "," T3 ");
        strLine = strLine.replaceAll(" t4 "," T4 ");
        strLine = strLine.replaceAll(" t5 "," T5 ");
        final String[] tableList = strLine.split(",");
        for (int x = 0; x < tableList.length; x++) {
            data.append("---" + System.getProperty("line.separator")
                    + "- Statement: " + tableList[x]
                    + System.getProperty("line.separator"));
        }
    }

    private void translateInclude(String strLine) {
        finishData();
        strLine = strLine.replaceAll("--source suite/engines/funcs/t/", "");
        final int dotPos = strLine.lastIndexOf(".");
        strLine = strLine.substring(0, dotPos) + ".yaml";
        data.append("---" + System.getProperty("line.separator")
                + "- Include: " + strLine
                + System.getProperty("line.separator"));
    }

    // leave final brackets for end
    // really should just skip first row
    protected void translateData(final String strLine) {
        if (!strLine.toUpperCase().startsWith("C1")
                && !strLine.toUpperCase().startsWith("COUNT")
                && !strLine.toUpperCase().startsWith("C2")
                && !strLine.toUpperCase().startsWith("C3")) {
            final boolean startedEmpty = tempData.length() == 0;
            if (!startedEmpty) {
                tempData.append(",");
            }
            realdata = strLine.split("\t");
            if (alldata == null) {
                alldata = new String[90000][realdata.length];
            }
            alldata[smallCounter] = realdata;
            smallCounter++;
            for (int x = 0; x < realdata.length; x++) {
                String preData = single_quote + realdata[x].replaceAll(single_quote, single_quote+single_quote) + single_quote;
                if (x == 0) {
                    tempData.append("[" + preData);
                } else {
                    tempData.append("," + preData);
                }
            }
            tempData.append("]");

        }

    }

    private void translateSelect(String strLine) {
        finishData();
        orderBy = 0;
        strLine = strLine.replaceAll("<=>", "=");
        strLine = strLine.replaceAll(";", "");
        blockData.append("---" + System.getProperty("line.separator")
                + "- Statement: " + strLine+System.getProperty("line.separator"));

    }

    private void translateStatement(String strLine) {
        finishData();
        //System.out.println("******Testing: "+strLine);
        strLine = strLine.replaceAll("ADDTIME\\(NOW\\(\\),'1 01:01:01'\\)", "ADDTIME(NOW(),INTERVAL '1 01:01:01' DAY_SECOND)");
        strLine = strLine.replaceAll("ADDTIME\\(NOW\\(\\),'2 02:01:01'\\)", "ADDTIME(NOW(),INTERVAL '2 02:01:01' DAY_SECOND)");
        strLine = strLine.replaceAll("ADDTIME\\(NOW\\(\\),'3 03:01:01'\\)", "ADDTIME(NOW(),INTERVAL '3 03:01:01' DAY_SECOND)");
        strLine = strLine.replaceAll("ADDTIME\\(NOW\\(\\),'4 04:01:01'\\)", "ADDTIME(NOW(),INTERVAL '4 04:01:01' DAY_SECOND)");
        strLine = strLine.replaceAll(" t4 "," T4 ");
        strLine = strLine.replaceAll(" t5 "," T5 ");
        //System.out.println("******Testing(POST): "+strLine);
        data.append("---" + System.getProperty("line.separator")
                + "- Statement: " + strLine
                + System.getProperty("line.separator"));

    }

    private void translateDropTable(String strLine) {
        finishData();

        if (!strLine.toUpperCase().contains("IF EXISTS")) {
            strLine = strLine.toUpperCase().replaceAll("IF EXISTS", "");
            strLine = strLine.toUpperCase().replaceAll("DROP TABLE", "");
            strLine = strLine.replaceAll(";", "");
            final String[] tableList = strLine.split(",");
            for (int x = 0; x < tableList.length; x++) {
                data.append("---" + System.getProperty("line.separator")
                        + "- DropTable: " + tableList[x]
                        + System.getProperty("line.separator"));
            }
        }

    }

    private void translateCreateTable(String strLine) {
        finishData();
        strLine = strLine.toUpperCase().replaceAll("CREATE TABLE", "");
        strLine = strLine.toUpperCase().replaceAll("TINYINT", "INT");
        strLine = strLine.toUpperCase().replaceAll("MEDIUMINT", "INT");
        strLine = strLine.toUpperCase().replaceAll("TEXT", "CLOB");
        strLine = strLine.toUpperCase().replaceAll("VARBINARY", "VARCHAR");
        strLine = strLine.toUpperCase().replaceAll("BINARY", "VARCHAR");
        strLine = strLine.toUpperCase().replaceAll("FIXED", "DECIMAL");
        strLine = strLine.toUpperCase().replaceAll("FLOAT", "DECIMAL");
        strLine = strLine.toUpperCase().replaceAll("DOUBLE", "DECIMAL");
        strLine = strLine.toUpperCase().replaceAll("REAL", "DECIMAL");
        strLine = strLine.toUpperCase().replaceAll("PRECISION", "");
        
        strLine = strLine.toUpperCase().replaceAll("T1\\(C", "T1 \\(C");
        strLine = strLine.toUpperCase().replaceAll("T2\\(C", "T2 \\(C");
        strLine = strLine.toUpperCase().replaceAll("T3\\(C", "T3 \\(C");
        strLine = strLine.toUpperCase().replaceAll("T4\\(C", "T4 \\(C");
        strLine = strLine.toUpperCase().replaceAll("T5\\(C", "T5 \\(C");

        strLine = strLine.toUpperCase().replaceAll("AUTO_INCREMENT","GENERATED BY DEFAULT AS IDENTITY");
        
        data.append("---" + System.getProperty("line.separator")
                + "- CreateTable: " + strLine
                + System.getProperty("line.separator"));

    }

    private void translateComment(String strLine) {
        finishData();
        strLine = strLine.replaceAll("--", "");
        data.append("# " + strLine + System.getProperty("line.separator"));
    }

    private void save(final String filename, final StringBuilder data2)
            throws IOException {
        try {
            final BufferedWriter out = new BufferedWriter(
                    new OutputStreamWriter(new FileOutputStream(filename),
                            "UTF8"));
            out.write(data2.toString());
            // Close the output stream
            out.close();
        } catch (final Exception e) {// Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }
        final File f = new File(filename);
        System.out.println(f.getCanonicalPath());
        System.out.println(data2.toString());

    }

    private void finishData() {
        if (blockData != null && blockData.length() > 0) {
            data.append(blockData);
            //data.append(System.getProperty("line.separator"));
            if (tempData != null && tempData.length() > 0) {
                String mod = tempData.toString();
                data.append("- output_ordered: [" + mod + "]"
                        + System.getProperty("line.separator"));
            } else {
                if (!blockData.toString().contains("warnings") && !blockData.toString().contains("error:")) {
                    data.append("- row_count: 0"
                        + System.getProperty("line.separator"));
                }
            }
            tempData = new StringBuilder();
            blockData = new StringBuilder();
            alldata = null;
            this.orderBy = 0;
            realdata = new String[1];
            smallCounter = 0;
        }
    }

}
