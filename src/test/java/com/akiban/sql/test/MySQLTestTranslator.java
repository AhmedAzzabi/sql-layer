/**
 * Copyright (C) 2011 Akiban Technologies Inc.
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses.
 */

package com.akiban.sql.test;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Date;

/*
 * translates the MySQL test files into our yaml format
 * */
public class MySQLTestTranslator {

    StringBuilder data = new StringBuilder();
    StringBuilder tempData = new StringBuilder();
    StringBuilder blockData = new StringBuilder();
    String[] realdata = new String[1];
    int orderBy = 0;
    String[][] alldata;
    int smallCounter = 0;
    final String target_path = System.getProperty("user.dir")
            + "/src/test/resources/com/akiban/sql/pg/yaml/mysql-test/";
    private static final String skip_key = "# AUTOGEN: SKIP";
    
    // It is also possible to filter the list of returned files.
    // This example does not return any files that start with `.'.
    final FilenameFilter filter = new FilenameFilter() {
        public boolean accept(final File dir, final String name) {
            boolean accept;
            accept = !name.startsWith(".")
                    && !name.startsWith("tc")
                    && !name.startsWith("db")
                    && !name.startsWith("rpl")
                    && (name.endsWith(".result") || (name.startsWith("data") && name
                            .endsWith(".inc")));
            return accept;
        }
    };
    
    /**
     * @param args
     */
    public static void main(String[] args) {
        final MySQLTestTranslator b = new MySQLTestTranslator();
        b.run(args[1]);
        System.out.println("Done!!!!");
    }

    public void run(final String directory) {
        final File dir = new File(directory);

        final String[] children = dir.list(filter);
        if (children == null) {
            System.err.println("Either dir does not exist or is not a directory");
        } else {
            for (int i = 0; i < children.length; i++) {
                // Get filename of file or directory
                processFile(directory + "/" + children[i]);
            }
        }
    }

    public void processFile(final String filename) {
        //Read filename (test.result)
        //process each line into data sb
        //write out data
        final int dashPos = filename.lastIndexOf("/") + 1;
        String strFilename = filename.substring(dashPos);
        final int dotPos = strFilename.lastIndexOf(".");
        strFilename = strFilename.replaceAll("_", "-");
        strFilename = "test-" + strFilename.substring(0, dotPos) + ".yaml";
        System.out.println("Processing: " + filename);
        if (checkTargetFile(target_path + strFilename)) {

            return;
        }

        data.append("# generated by com.akiban.sql.test.MySQLTestTranslator on "
                + new Date() + System.getProperty("line.separator"));
        if (!strFilename.startsWith("test-se")) {
            data.append("---" + System.getProperty("line.separator"));
            data.append("- Properties: all"
                    + System.getProperty("line.separator"));
            data.append("- suppressed: true"
                    + System.getProperty("line.separator"));
        }
        //data.append("---" + System.getProperty("line.separator"));

        try {
            final FileInputStream fstream = new FileInputStream(filename);
            // Get the object of DataInputStream
            final DataInputStream in = new DataInputStream(fstream);
            final BufferedReader br = new BufferedReader(new InputStreamReader(
                    in));
            String strLine;
            //Read File Line By Line
            while ((strLine = br.readLine()) != null) {
                strLine = strLine.replaceAll("\\u0000", "");
                //System.out.println(strLine);

                if (strLine.toUpperCase().startsWith("CREATE TABLE")) {
                    translateCreateTable(strLine);
                } else if (strLine.toUpperCase().startsWith("INSERT")) {
                    translateStatement(strLine);
                } else if (strLine.toUpperCase().startsWith("DELETE")) {
                    translateStatement(strLine);
                } else if (strLine.toUpperCase().startsWith("UPDATE")) {
                    translateStatement(strLine);
                } else if (strLine.toUpperCase().startsWith("SELECT")) {
                    translateSelect(strLine);
                } else if (strLine.toUpperCase().startsWith("TRUNCATE TABLE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("--SOURCE")) {
                    translateInclude(strLine);
                } else if (strLine.toUpperCase().startsWith("DROP TABLE")) {
                    translateDropTable(strLine);
                } else if (strLine.toUpperCase().startsWith("ERROR")) {
                    translateError(strLine);
                } else if (strLine.toUpperCase().startsWith("--")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("End of")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith(";")) {
                    // skip line
                } else if (strLine.toUpperCase().startsWith("STOP")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("START")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("PARTITION")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("SHOW")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("RESET")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("SET")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("WARNING")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("LOAD")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("USE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("CREATE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("DROP DATABASE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("ANALYZE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("DROP INDEX")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("DROP VIEW")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("ALTER")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("EXECUTE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("PREPARE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("REPLACE")) {
                    translateComment(strLine);
                } else if (strLine.toUpperCase().startsWith("DEALLOCATE")) {
                    translateComment(strLine);
                } else if (strLine.length() > 0) {
                    translateData(strLine);
                }
            }
            //Close the input stream
            in.close();
        } catch (final Exception e) {//Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }

        data.append("..." + System.getProperty("line.separator"));

        try {
            // will drop the files in the same branch as where this code is running
            // sql gets dropped in the root directory of branch

            System.out.println("Writing out " + target_path + strFilename);
            save(target_path + strFilename, data);
        } catch (final IOException e) {
            System.err.println("Error: " + e.getMessage());
        }
        data = new StringBuilder();
    }

    /* return true to skip processing file because target file is working
     don't mess with it
     */
    private boolean checkTargetFile(String strFilename) {
        boolean retVal = false;
        File f = new File(strFilename);
        if (f.exists()) {

            BufferedReader br = null;
            try {
                br = new BufferedReader(new FileReader(strFilename));
                String strLine;
                //Read File Line By Line

                while (!retVal && (strLine = br.readLine()) != null) {
                    if (strLine.contains(skip_key)) {
                        retVal = true;
                    }
                }
            } catch (IOException e) {
                System.err.println("Error: " + e.getMessage());
            } finally {
                //Close the input stream
                try {
                    br.close();
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
        return retVal;
    }

    private void translateError(String strLine) {
        blockData.append("- error: ['" + strLine + "']"
                + System.getProperty("line.separator"));
    }

    @SuppressWarnings("unused")
    private void translateTruncateTable(String strLine) {
        finishData();

        strLine = strLine.toUpperCase().replaceAll("TRUNCATE TABLE", "");
        strLine = strLine.replaceAll(";", "");
        final String[] tableList = strLine.split(",");
        for (int x = 0; x < tableList.length; x++) {
            data.append("---" + System.getProperty("line.separator")
                    + "- TruncateTable: " + tableList[x]
                    + System.getProperty("line.separator"));
        }
    }

    private void translateInclude(String strLine) {
        finishData();
        strLine = strLine.replaceAll("--source suite/engines/funcs/t/", "");
        final int dotPos = strLine.lastIndexOf(".");
        strLine = strLine.substring(0, dotPos) + ".yaml";
        data.append("---" + System.getProperty("line.separator")
                + "- Include: " + strLine
                + System.getProperty("line.separator"));
    }

    // leave final brackets for end
    // really should just skip first row
    protected void translateData(final String strLine) {
        if (!strLine.toUpperCase().startsWith("C1")
                && !strLine.toUpperCase().startsWith("COUNT")
                && !strLine.toUpperCase().startsWith("C2")
                && !strLine.toUpperCase().startsWith("C3")) {
            final boolean startedEmpty = tempData.length() == 0;
            if (!startedEmpty) {
                tempData.append(",");
            }
            realdata = strLine.split("\t");
            if (alldata == null) {
                alldata = new String[90000][realdata.length];
            }
            alldata[smallCounter] = realdata;
            smallCounter++;
            for (int x = 0; x < realdata.length; x++) {
                if (x == 0) {
                    tempData.append("[" + realdata[x]);
                } else {
                    tempData.append("," + realdata[x]);
                }
            }
            tempData.append("]");

        }

    }

    private void translateSelect(String strLine) {
        finishData();
        orderBy = 0;
        strLine = strLine.replaceAll("<=>", "=");
        strLine = strLine.replaceAll(";", "");
        blockData.append("---" + System.getProperty("line.separator")
                + "- Statement: " + strLine);

    }

    private void translateStatement(final String strLine) {
        finishData();
        data.append("---" + System.getProperty("line.separator")
                + "- Statement: " + strLine
                + System.getProperty("line.separator"));

    }

    private void translateDropTable(String strLine) {
        finishData();

        if (!strLine.toUpperCase().contains("IF EXISTS")) {
            strLine = strLine.toUpperCase().replaceAll("IF EXISTS", "");
            strLine = strLine.toUpperCase().replaceAll("DROP TABLE", "");
            strLine = strLine.replaceAll(";", "");
            final String[] tableList = strLine.split(",");
            for (int x = 0; x < tableList.length; x++) {
                data.append("---" + System.getProperty("line.separator")
                        + "- DropTable: " + tableList[x]
                        + System.getProperty("line.separator"));
            }
        }

    }

    private void translateCreateTable(String strLine) {
        finishData();
        strLine = strLine.toUpperCase().replaceAll("CREATE TABLE", "");
        strLine = strLine.toUpperCase().replaceAll("TINYINT", "INT");
        strLine = strLine.toUpperCase().replaceAll("MEDIUMINT", "INT");
        strLine = strLine.toUpperCase().replaceAll("TEXT", "CLOB");
        strLine = strLine.toUpperCase().replaceAll("VARBINARY", "VARCHAR");
        strLine = strLine.toUpperCase().replaceAll("BINARY", "VARCHAR");
        strLine = strLine.toUpperCase().replaceAll("T1\\(C1", "T1 \\(C1");

        data.append("---" + System.getProperty("line.separator")
                + "- CreateTable: " + strLine
                + System.getProperty("line.separator"));

    }

    private void translateComment(String strLine) {
        finishData();
        strLine = strLine.replaceAll("--", "");
        data.append("# " + strLine + System.getProperty("line.separator"));
    }

    private void save(final String filename, final StringBuilder data2)
            throws IOException {
        try {
            final BufferedWriter out = new BufferedWriter(
                    new OutputStreamWriter(new FileOutputStream(filename),
                            "UTF8"));
            out.write(data2.toString());
            // Close the output stream
            out.close();
        } catch (final Exception e) {// Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }
        final File f = new File(filename);
        System.out.println(f.getCanonicalPath());
        System.out.println(data2.toString());

    }

    private void finishData() {
        if (blockData != null && blockData.length() > 0) {
            data.append(blockData);
            data.append(";" + System.getProperty("line.separator"));
            if (tempData != null && tempData.length() > 0) {
                data.append("- output_ordered: [" + tempData.toString() + "]"
                        + System.getProperty("line.separator"));
            } else {
                data.append("- row_count: 0"
                        + System.getProperty("line.separator"));
            }
            tempData = new StringBuilder();
            blockData = new StringBuilder();
            alldata = null;
            this.orderBy = 0;
            realdata = new String[1];
            smallCounter = 0;
        }
    }

}
