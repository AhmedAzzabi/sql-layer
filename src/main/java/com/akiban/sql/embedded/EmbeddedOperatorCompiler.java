/**
 * END USER LICENSE AGREEMENT (“EULA”)
 *
 * READ THIS AGREEMENT CAREFULLY (date: 9/13/2011):
 * http://www.akiban.com/licensing/20110913
 *
 * BY INSTALLING OR USING ALL OR ANY PORTION OF THE SOFTWARE, YOU ARE ACCEPTING
 * ALL OF THE TERMS AND CONDITIONS OF THIS AGREEMENT. YOU AGREE THAT THIS
 * AGREEMENT IS ENFORCEABLE LIKE ANY WRITTEN AGREEMENT SIGNED BY YOU.
 *
 * IF YOU HAVE PAID A LICENSE FEE FOR USE OF THE SOFTWARE AND DO NOT AGREE TO
 * THESE TERMS, YOU MAY RETURN THE SOFTWARE FOR A FULL REFUND PROVIDED YOU (A) DO
 * NOT USE THE SOFTWARE AND (B) RETURN THE SOFTWARE WITHIN THIRTY (30) DAYS OF
 * YOUR INITIAL PURCHASE.
 *
 * IF YOU WISH TO USE THE SOFTWARE AS AN EMPLOYEE, CONTRACTOR, OR AGENT OF A
 * CORPORATION, PARTNERSHIP OR SIMILAR ENTITY, THEN YOU MUST BE AUTHORIZED TO SIGN
 * FOR AND BIND THE ENTITY IN ORDER TO ACCEPT THE TERMS OF THIS AGREEMENT. THE
 * LICENSES GRANTED UNDER THIS AGREEMENT ARE EXPRESSLY CONDITIONED UPON ACCEPTANCE
 * BY SUCH AUTHORIZED PERSONNEL.
 *
 * IF YOU HAVE ENTERED INTO A SEPARATE WRITTEN LICENSE AGREEMENT WITH AKIBAN FOR
 * USE OF THE SOFTWARE, THE TERMS AND CONDITIONS OF SUCH OTHER AGREEMENT SHALL
 * PREVAIL OVER ANY CONFLICTING TERMS OR CONDITIONS IN THIS AGREEMENT.
 */

package com.akiban.sql.embedded;

import com.akiban.sql.embedded.JDBCResultSetMetaData.ResultColumn;
import com.akiban.sql.embedded.JDBCParameterMetaData.ParameterType;

import com.akiban.sql.server.ServerOperatorCompiler;
import com.akiban.sql.server.ServerPlanContext;

import com.akiban.sql.optimizer.NestedResultSetTypeComputer;
import com.akiban.sql.optimizer.TypesTranslation;
import com.akiban.sql.optimizer.plan.BasePlannable;
import com.akiban.sql.optimizer.plan.PhysicalSelect.PhysicalResultColumn;
import com.akiban.sql.optimizer.plan.PhysicalSelect;
import com.akiban.sql.optimizer.plan.PhysicalUpdate;
import com.akiban.sql.optimizer.plan.ResultSet.ResultField;
import com.akiban.sql.optimizer.rule.PlanContext;

import com.akiban.sql.StandardException;
import com.akiban.sql.parser.*;
import com.akiban.sql.types.DataTypeDescriptor;
import com.akiban.sql.types.TypeId;

import com.akiban.ais.model.AkibanInformationSchema;
import com.akiban.ais.model.Column;
import com.akiban.ais.model.UserTable;
import com.akiban.qp.operator.Operator;
import com.akiban.server.error.SQLParserInternalException;
import com.akiban.server.error.UnsupportedSQLException;
import com.akiban.server.service.functions.FunctionsRegistry;
import com.akiban.server.types3.TInstance;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.Types;
import java.util.*;

public class EmbeddedOperatorCompiler extends ServerOperatorCompiler
{
    private static final Logger logger = LoggerFactory.getLogger(EmbeddedQueryContext.class);

    protected EmbeddedOperatorCompiler() {
    }

    protected static EmbeddedOperatorCompiler create(JDBCConnection connection) {
        EmbeddedOperatorCompiler compiler = new EmbeddedOperatorCompiler();
        compiler.initServer(connection);
        compiler.initDone();
        return compiler;
    }

    @Override
    public PhysicalResultColumn getResultColumn(ResultField field) {
        return getJDBCResultColumn(field.getName(), field.getSQLtype(), field.getAIScolumn(), field.getTInstance());
    }

    protected ResultColumn getJDBCResultColumn(String name, DataTypeDescriptor sqlType, 
                                               Column aisColumn, TInstance tInstance) {
        int jdbcType = Types.OTHER;
        JDBCResultSetMetaData nestedResultSet = null;
        if (sqlType != null) {
            jdbcType = sqlType.getJDBCTypeId();
            if (sqlType.getTypeId().isRowMultiSet()) {
                TypeId.RowMultiSetTypeId typeId = 
                    (TypeId.RowMultiSetTypeId)sqlType.getTypeId();
                String[] columnNames = typeId.getColumnNames();
                DataTypeDescriptor[] columnTypes = typeId.getColumnTypes();
                List<ResultColumn> nestedResultColumns = new ArrayList<>(columnNames.length);
                for (int i = 0; i < columnNames.length; i++) {
                    nestedResultColumns.add(getJDBCResultColumn(columnNames[i], columnTypes[i], null, TypesTranslation.toTInstance(columnTypes[i])));
                }
                nestedResultSet = new JDBCResultSetMetaData(nestedResultColumns);
            }
        }
        return new ResultColumn(name, jdbcType, sqlType, aisColumn, tInstance, nestedResultSet);
    }

    public ExecutableStatement compileExecutableStatement(DMLStatementNode sqlStmt, List<ParameterNode> sqlParams, boolean getParameterNames, ExecuteAutoGeneratedKeys autoGeneratedKeys, EmbeddedQueryContext context) {
        if (autoGeneratedKeys != null) {
            if (!(sqlStmt instanceof DMLModStatementNode))
                throw JDBCException.wrapped("SELECT Statement does not generate keys");
            DMLModStatementNode updateStmt = (DMLModStatementNode)sqlStmt;
            if (updateStmt.getReturningList() != null)
                throw JDBCException.wrapped("Statement already has RETURNING");
            addAutoGeneratedReturning(updateStmt, autoGeneratedKeys);
        }
        PlanContext planContext = new ServerPlanContext(this, context);
        BasePlannable result = compile(sqlStmt, sqlParams, planContext);
        Operator resultOperator = (Operator)result.getPlannable();
        JDBCResultSetMetaData resultSetMetaData = null;
        if (!result.isUpdate() || ((PhysicalUpdate)result).isReturning()) {
            List<ResultColumn> columns = new ArrayList<>();
            for (PhysicalResultColumn column : result.getResultColumns()) {
                columns.add((ResultColumn)column);
            }
            resultSetMetaData = new JDBCResultSetMetaData(columns);
        }
        JDBCParameterMetaData parameterMetaData = null;
        if (result.getParameterTypes() != null) {
            List<ParameterType> jdbcParams = new ArrayList<>();
            for (DataTypeDescriptor sqlType : result.getParameterTypes()) {
                jdbcParams.add(new ParameterType(sqlType));
            }
            parameterMetaData = new JDBCParameterMetaData(jdbcParams);
            if (getParameterNames) {
                // TODO: Only case through here will be ? = CALL fun(?,?,...),
                // which will look like SELECT fun(...).
            }
        }
        if (result.isUpdate())
            return new ExecutableModifyOperatorStatement(resultOperator,
                                                         resultSetMetaData,
                                                         parameterMetaData,
                                                         ((PhysicalUpdate)result).isRequireStepIsolation());
        else
            return new ExecutableQueryOperatorStatement(resultOperator,
                                                        resultSetMetaData,
                                                        parameterMetaData,
                                                        result.getCostEstimate());
    }

    protected void addAutoGeneratedReturning(DMLModStatementNode updateStmt, 
                                             ExecuteAutoGeneratedKeys autoGeneratedKeys) {
        try {
            TableName tableName = updateStmt.getTargetTableName();
            String schemaName = tableName.getSchemaName();
            if (schemaName == null)
                schemaName = getDefaultSchemaName();
            UserTable table = getSchema().ais().getUserTable(schemaName,  
                                                             tableName.getTableName());
            if (table == null) return; // Assuming same error will occur later.
            List<Column> columns = autoGeneratedKeys.getTargetColumns(table);

            NodeFactory nodeFactory = updateStmt.getNodeFactory();
            SQLParserContext parserContext = updateStmt.getParserContext();
            ResultColumnList rcl = (ResultColumnList)
                nodeFactory.getNode(NodeTypes.RESULT_COLUMN_LIST,
                                    parserContext);
            for (Column column : columns) {
                String columnName = column.getName();
                ColumnReference columnRef = (ColumnReference)
                    nodeFactory.getNode(NodeTypes.COLUMN_REFERENCE,
                                        columnName, tableName,
                                        parserContext);
                com.akiban.sql.parser.ResultColumn resultColumn = (com.akiban.sql.parser.ResultColumn)
                    nodeFactory.getNode(NodeTypes.RESULT_COLUMN,
                                        columnName, columnRef,
                                        parserContext);
                rcl.addResultColumn(resultColumn);
            }
            updateStmt.setReturningList(rcl);
        }
        catch (StandardException ex) {
            throw new SQLParserInternalException(ex);
        }
    }

    // TODO: Consider making these depend on a connection string parameter.

    @Override
    protected void initAIS(AkibanInformationSchema ais, String defaultSchemaName) {
        super.initAIS(ais, defaultSchemaName);
        binder.setAllowSubqueryMultipleColumns(true);
    }

    @Override
    protected void initFunctionsRegistry(FunctionsRegistry functionsRegistry) {
        super.initFunctionsRegistry(functionsRegistry);
        typeComputer = new NestedResultSetTypeComputer(functionsRegistry);
    }
}
