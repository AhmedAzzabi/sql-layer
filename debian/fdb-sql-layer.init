#! /bin/sh
### BEGIN INIT INFO
# Provides:          fdb-sql-layer
# Required-Start:    $remote_fs
# Required-Stop:     $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: FoundationDB SQL Layer
# Description:       FoundationDB SQL Layer
### END INIT INFO

# Author: Nathan Williams <nathan.williams@foundationdb.com>

export JAR_FILE=/usr/share/foundationdb-sql/fdb-sql-layer.jar
export DEP_DIR=/usr/share/foundationdb-sql/server
export FDBSQL_CONF=/etc/foundationdb-sql
export FDBSQL_HOME=/usr/share/foundationdb-sql
export FDBSQL_OWNR=foundationdb-sql
SELF=$(cd $(dirname $0); pwd -P)/$(basename $0)
NAME="foundationdb-sql"
DESC="FoundationDB SQL Layer"
log_file=/var/log/foundationdb-sql/server_stdout.log
PIDFILE_DIR=/var/run/$NAME
pidfile=$PIDFILE_DIR/server.pid
timeout=60
FDBSQL_PROG=/usr/sbin/fdbsqllayer
DAEMON=/usr/sbin/fdbsqllayer

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] && . /etc/default/$NAME

# /var/run is a tmpfs filesystem on ubuntu
# on reboot and during upgrades, its contents can be wiped
if [ ! -d $PIDFILE_DIR ]; then
    mkdir $PIDFILE_DIR
    chown $FDBSQL_OWNR $PIDFILE_DIR
fi

[ -e "$JAR_FILE" ] || exit 0
[ -e "$FDBSQL_CONF/jvm.options" ] || exit 0

# read JVM options
. /etc/foundationdb-sql/jvm.options

if [ -z "$JVM_OPTS" ]; then
    echo "Initialization failed; \$JVM_OPTS not set!" >&2
    exit 3
fi

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions

#
# Function that returns 0 if process is running, or nonzero if not.
#
# The nonzero value is 3 if the process is simply not running, and 1 if the
# process is not running but the pidfile exists (to match the exit codes for
# the "status" command; see LSB core spec 3.1, section 20.2)
#
CMD_PATT="foundationdb-sql"
is_running()
{
    if [ -f $pidfile ]; then
        pid=`cat $pidfile`
        grep -Eq "$CMD_PATT" "/proc/$pid/cmdline" 2>/dev/null && return 0
        return 1
    fi
    return 3
}

check_no_process()
{
    if [ ! -e "$pidfile" ]; then
        check_pid=`pgrep -f "cp $JAR_FILE"`
        if [ "$check_pid" != "" ]; then
            return 1
        fi
    fi
    return 0
}

case "$1" in
    start)
        is_running
        stat=$?
        if [ "$stat" = "0" ]; then
            log_failure_msg "$DESC is already running"
            exit "$stat"
        fi
        check_no_process
        if [ $? -ne 0 ]; then
            log_failure_msg "$DESC is already running but no pidfile exists"
            exit 1
        fi
        log_daemon_msg "Starting $DESC"
        start_daemon "$DAEMON --chuid $FDBSQL_OWNR" "-p $pidfile" "-j $JAR_FILE" "-d $DEP_DIR" "-c $FDBSQL_CONF" > $log_file 2>&1 &
        # we give server 60 seconds to start all services
        attempts=1
        while [ ! -f $pidfile ]
        do
            attempts=$(($attempts+1))
            if [ $attempts = $timeout ]; then
                break
            fi
            sleep 1
        done
        if [ -f $pidfile ]; then
            log_end_msg 0
        else
            log_failure_msg "$DESC failed to start correctly"
        fi
        ;;
    stop)
        is_running
        stat=$?
        case "$stat" in
            1) 
                log_failure_msg "could not access pidfile or PID in pidfile is incorrect for $DESC"
                exit 0 # zero exit code because apt-get remove fails otherwise
                ;;
            3) 
                log_failure_msg "$DESC is not running or no pidfile exists"
                exit 0 # zero exit code because apt-get remove fails otherwise
                ;;
        esac 
        log_daemon_msg "Stopping $DESC"
        if [ -f "$pidfile" ]; then
            killproc -p "$pidfile" "$DAEMON"
            log_progress_msg "$DESC"
        fi
        # we give server 60 seconds to shut down
        attempts=1
        while [ -f $pidfile ]
        do
            attempts=$(($attempts+1))
            if [ $attempts = $timeout ]; then
                break
            fi
            sleep 1
        done
        if [ -f $pidfile ]; then
            log_failure_msg "$DESC failed to shutdown cleanly"
        else
            log_end_msg 0
        fi
        ;;
    force-reload|restart)
        set +e; $SELF stop; set -e
        sleep 5
        $SELF start
        ;;
    status)
        check_no_process
        if [ $? -ne 0 ]; then
            log_failure_msg "$DESC is running (pid $check_pid) but no pidfile exists"
            exit 1
        fi
        is_running
        stat=$?
        case "$stat" in
          0) log_success_msg "$DESC is running" ;;
          1) log_failure_msg "could not access pidfile for $DESC" ;;
          *) log_success_msg "$DESC is not running" ;;
        esac
        exit "$stat"
        ;;
    *)
        echo "Usage: $SELF start|stop|status|restart|force-reload"
        exit 3
esac

